\section{Model Definitions}
\label{sec:definitions}
In this section I will present the definition of the basic components of a stream processing system as
they are intended in the scope of this work. Many of the concepts are similar or equivalent to their
counterparts described already when presenting CQL and the Boxes-and-Arrows query model. Nevertheless a
precise definition of many concepts used throughout this document is necessary for the correct understanding of
this work.

%--------------------------------------------------------------------------------------------------------
\begin{definition}[Schema]{ 
A schema $S$ is a data structure of elements in the form: $\langle Type, Name \rangle$.
}
\end{definition}

A \textit{schema} defines the structure of a the payload contained in a tuple. It is formed by a series
of $\langle Type, Name \rangle$ couples, each specifying the abstract type and the name of an element. It is
equivalent to a schema used in a relational database, where it is used to describe the columns forming a
table. 

\underline{\textsc{Example}}: Consider a tuple with the following schema:\\

\begin{table}[th!]
	\centering
	\begin{tabular}{|c||c|} \hline
	%notation & description \\ \hline
	\textit{Integer} 	&	\textsc{NodeID}		\\	\hline
	\textit{Double}		&	\textsc{CpuLoad}	\\	\hline
	\textit{Long}		&	\textsc{UpTime}		\\	\hline
	\end{tabular}
	
	%\caption{Schema of a tuple containing load and uptime information for a specific processing node.}
	\label{table:schema}
\end{table}

It contains information about load and uptime for a specific processing node. Each field is named so that
it can be referred to when processing the tuple and a is assigned an abstract type which will be
translated to a system type once the tuple is instantiated.

%--------------------------------------------------------------------------------------------------------

\begin{definition}[Tuple]{ 
A tuple is an element $t = \langle \tau, \textrm{SIC}, \mathcal{V} \rangle$, where $\tau \in T$ is the
timestamp of the element, \sic is the source information content metadata value and 
$\mathcal{V}$ is a set of values defined by a schema $S$.
}
\end{definition}

A \textit{tuple} is the basic information vector within a data stream processing system, representing a
single unit of data. In our model a tuple is composed by three main elements: a
\textit{timestamp}, a \textit{\sic} metadata value and a \textit{payload}.

With timestamp we mean an indication of when the tuple was produced. This usually is equivalent to the
time at which the tuple enters the system, in this case the sources are only concerned with the
production of the raw data and the timestamp is assigned by the system as the UTC time at the moment of
input. It is also possible for the timestamp to be set externally, which is particularly useful in case
of syntetic workloads. In this case the timestamp is determined by an external entity and the system merely
accepts this values without checking their correctness. In Section~\ref{sec:input-devices} I will present
the different operators  dealing with the acceptance of tuples in the system and their policies when
dealing with timestamps.

In our system a tuple is always augmented with a \sic metadata value, which is an indication of the
amount of information carried by the tuple. This value is calculated autonomously by the system and
varies according to the amount of failure (tuple loss) which occurred in the generation of the tuple.
This value has two main functions: it reports back to the user the achieved quality of service for the
current processing and it is used internally by the system to make intelligent load shedding decisions
under overload.

The third element composing a tuple is the \textit{payload}. This contains the actual
information carried by the tuple. It is formed by one or more values of any primitive datatype. 
The type and the order of the values forming a tuple payload is defined by a schema.

Logically we can divide tuples in three categories. A \textit{source} tuple, $t_{sr}$, is a tuple
generated from a source representing a single input to the system. A \textit{derived} tuple, $t_{op} \in
\mathcal{T}_{out}^{o}$, is a tuple generated by an intermediate operator. 
Finally there are \textit{output} tuples, $t_{out}$, which are derived tuples produced by a
terminal operator. These contains the final results of the processing which are delivered to the
user together with the complete \sic value.

\underline{\textsc{Example}}: Figure~\ref{fig:tuple} shows a simple tuple with the relative schema.
 
\begin{figure}[b!]
	\centering
	\includegraphics[width=0.8\textwidth]{img/tesi/tuple}
	\caption{A simple tuple with the relative schema.}
	\label{fig:tuple}
\end{figure}

The discussion about our implementation of tuples is given in Section~\ref{sec:tuples}.
%--------------------------------------------------------------------------------------------------------

\begin{definition}[Batch]{
A batch is a finite set of tuples $B=\{t_1,\dots,t_n\}$, all having the same \sic metadata value.
}
\end{definition}

A \textit{batch} is a logical group of tuples all having the same \sic value. In our system an operator
does not work on a single tuple but on batches, it processes one or more input batches and produces one
output batch, which might be composed of a single tuple.

Using batches allows for a more compact representation of the \sic metadata, as it does not have to be
included with each tuple. It also speeds up the calculation of the new \sic value when an operator
outputs a new set of tuples. 

Batches represent a snapshot of a stream, a finite amount of tuples that can be processed by an
operator. In our system they represent the equivalent of \textit{relations} used by CQL.

The discussion about our implementation of batches is given in Section~\ref{sec:batches}.

\begin{table}[b!]
\centering
\begin{tabular}{|c||c|} \hline
%notation & description \\ \hline
\multicolumn{2}{|c|}{{\bf Model Notation}} \\ \hline \hline
$t$                     & tuple\\ \hline
$t_{\tau}$              & generation timestamp of tuple $t$  \\ \hline
$t_{SIC}$               & \sic value of tuple $t$ \\ \hline
$t_{\mathcal{V}}$       & set of schema values of tuple $t$ \\ \hline
$\mathcal{O}$           & set of all operators of a query \\ \hline
$\mathcal{S}$           & set of all sources attached to a query \\ \hline
$\mathcal{T}^{S}$       & source information tuple set  \\ \hline
%$\mathbb{T}^{S}$       & set of source tuples space \\ \hline
$t^{R}$                 & query result tuple  \\ \hline
$\mathbb{T}^{R}$        & stream of query result tuples \\ \hline
$f$                     & query function \\ \hline
$f^{-1}$                & inverse query function \\ \hline
$\mathcal{T}_{in}^{o}$  & set of input tuples to operator $o$  \\ \hline
$\mathcal{T}_{out}^{o}$ & set of output tuples of operator $o$  \\ \hline
%\multicolumn{2}{|c|}{{\bf notation for the data streaming system}} \\ \hline \hline
$\mathcal{N}$           & set of nodes \\ \hline
$\mathcal{Q}$           & set of queries \\ \hline
$\mathbb{T}^{R}_{q}$    & stream of result tuples for query $q$\\ \hline
\end{tabular}
\caption{Notation used in the model definitions.\label{table:query}}
\end{table}
%--------------------------------------------------------------------------------------------------------

\begin{definition}[Stream] {
A stream is a possibly unbounded time-ordered set of tuples, all belonging to the same schema.}
\end{definition}

A \textit{stream} is a logical abstraction over tuples and batches. It represents the totality of the
tuples flowing between two operators. It is time ordered, meaning that a tuple $t_2$ received after a
tuple $t_1$ will always have a timestamp greater or equal than the former, such as $\tau_2 \geq
\tau_1$.

We can distinguish between \textit{base} streams, \textit{derived} streams and \textit{output} streams.
Base streams are generated from sources and are the input to the system. Derived streams are produced as 
an output by the operators of a running query. Output streams, $\mathbb{T}^{R}$, are derived streams
produced by a terminal operator, these contains the results of the processign delivered to the user.

A stream is only used logically to describe a possibly unbounded bag of similar tuples flowing between
two operators. As for CQL the system needs a finite amount of tuples to operate, which in our system is
represented by a \textit{batch}.

%--------------------------------------------------------------------------------------------------------

\begin{definition}[Operator]{
An operator is a function $f_{op}$ over a set of input streams $S_{in}=\{S_1,\dots,S_n\}$,
that generates a new output stream $S_{out}$=$f_{op}(S_{in})$. 
}
\end{definition}
 
An \textit{operator} is the basic processing unit within a stream processing system. It represents a
function over a set of input streams, transforming  one or more input batches into one output batch. 

Operators are seen as \textit{black boxes} in our system, meaning that their internal semantic is not
taken into account when calculating the \sic value for the newly generated output tuples.
We can divide operators based on their behaviour when dealing with input streams into two categories:
blocking and non-blocking.

\textit{Blocking} operators need to have at least one input batch ready on each of their input
streams. For instance if there are two inputs to an operator and one stream has delivered two input
batches, while the other one is currently empty, the operator blocks until an input batches arrives
on the second input stream. When this happens the first batch of each input is removed and processed,
producing one output batch. Assuming no other batch has arrived on the second input, the operator then
blocks again, as only the first input contains data to be processed. The discussion about our
implementation of blocking operators is given in Section~\ref{sec:bops}.

\textit{Non-Blocking} operators do not need input on all channel to be triggered. Instead they produce
and output batch as soon as some input batch is present on one of their input channels. This means that
such an operator will never block waiting for input, and will never have pending input data. The
discussion about our implementation of blocking operators is given in Section~\ref{sec:nbops}.

\begin{figure}[b!]
	\centering
	\includegraphics[width=0.7\textwidth]{img/tesi/operator} %XXX: rifare figura
	\caption{A black-box operator with two inputs and one output.}
	\label{fig:tuple}
\end{figure}

%--------------------------------------------------------------------------------------------------------

\begin{definition}[Query]{
A query logically defines a series of processing steps over set of input streams 
$S_{in}=\{S_{in}^1,\dots,S_{in}^n\}$ to produce a desired set of output streams 
$S_{out}=\{S_{out}^1,\dots,S_{out}^n\}$ by the mean of a finite number of operators.
}
\end{definition}

A query describes the processing to transform a set of input streams into a set of output streams.
In the boxes-and-arrows model, queries are depicted as a directed acyclic graph (DAG) where arcs
represent streams and vertices represent operators. One or more sources produce streams of tuples in 
various time-variant rates, which are fed in input to the system. Then one or more operators process 
these tuples, either in sequence or in parallel. 

A query is a graph where vertices correspond to operators and arcs indicate the direction of tuples
flowing from one or more sources to one or more terminal operators. The set of query operators is
given by $\mathcal{O}$ and cumulatively computes the query function $f$. Operators might be distributed
over a set of nodes $N$, when the query function is too complex to be computed on a single machine.

The discussion about our implementation of queries is given in Section~\ref{sec:queries}.

%--------------------------------------------------------------------------------------------------------

\begin{definition} [Source Information Tuple Set]
The source information tuple set $\mathcal{T}^{S}$ of a result tuple $t^{R}$ is the set of source tuples
given by function $f^{-1}: \mathbb{T}^{R} \rightarrow \mathbb{T}^{S}$ when applied over $t^{R}$, \ie
$f^{-1}(t^{R})=\mathcal{T}^{S}$.  $\mathbb{T}^{S} = \{ \mathcal{T}^{S}_{s} | s \in \mathcal{S}\}$, where
$\mathcal{T}^{S}_{s}$ denotes the set of source tuples in $\mathcal{T}^{S}$ generated from source $s$.
\end{definition}

\mnote{the definition is taken from the fissp paper, but seems a bit too complicated to me.}

In our query model every result tuple $t^{R}$ is associated to the set of source tuples
$\mathcal{T}^{S}$ that contributed to its generation. We take the simplistic approach to consider a
data streaming query as a black-box modeled after an one-to-one \emph{query function} $f$ that maps source 
to result tuples and ignores any derived tuples generated by the operators. The \textit{source
information tuple set} of a result tuple, is the set of all source tuples that were processed for its
creation. 

This concept is central to the definition of our quality centric metric called \textit{Source Information
Content} (\sic). The main idea behind it is that a result tuple is considered to be perfect when no
information is lost during its creation, meaning that all tuples in its source information tuple set or
their derivatives are correctly processed. If one of the tuples from the source information tuple set or
a derivative is lost, either because of failure or deliberate shedding, the information contained in the
result tuple is not perfect and its \sic value is decreased accordingly. 
